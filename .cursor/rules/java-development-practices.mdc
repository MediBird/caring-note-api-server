---
description: 
globs: *.java
alwaysApply: false
---
# Java 개발 실천 규칙

## 기본 개발 원칙
- SOLID 원칙 준수
  - 단일 책임 원칙(SRP): 각 클래스는 하나의 책임만 가지며, 그 책임을 완전히 캡슐화해야 함
  - 개방-폐쇄 원칙(OCP): 확장에는 열려 있으나 수정에는 닫혀 있어야 함
  - 리스코프 치환 원칙(LSP): 하위 타입은 상위 타입을 대체할 수 있어야 함
  - 인터페이스 분리 원칙(ISP): 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함
  - 의존성 역전 원칙(DIP): 추상화에 의존해야 하며, 구체화에 의존하지 않아야 함
- DRY(Don't Repeat Yourself) 원칙 준수
- KISS(Keep It Simple, Stupid) 원칙 준수
- YAGNI(You Aren't Gonna Need It) 원칙 준수

## 코드 보안 강화
- 모든 사용자 입력은 검증 및 유효성 검사 수행
- 인증과 인가 처리 철저히 분리
- JWT 토큰 관리:
  - 만료 시간은 15분 이내로 설정
  - Refresh 토큰 사용하여 사용자 경험 개선
  - 토큰에 민감한 정보 포함 금지
- XSS, CSRF, SQL 인젝션 등 OWASP Top 10 취약점 방어 코드 작성
- API 요청 제한(Rate Limiting) 구현:
  - IP 기반 및 사용자 기반 제한 설정
  - 임계값 초과 시 적절한 오류 응답 반환 (429 Too Many Requests)
- 민감 데이터 암호화:
  - 개인정보는 반드시 암호화하여 저장
  - 데이터베이스 컬럼 수준에서 암호화 적용
  - 전송 중인 데이터는 항상 HTTPS 사용

## 로깅 및 모니터링
- 로깅 표준화:
  - ERROR: 시스템 오류 및 예외 상황
  - WARN: 잠재적 문제 상황
  - INFO: 주요 비즈니스 이벤트, 사용자 인증 등
  - DEBUG: 개발 및 디버깅 목적의 상세 정보
- 로그 내용에 민감한 개인정보 포함 금지
- 로그 포맷 표준화: 타임스탬프, 요청 ID, 사용자 ID, 소스 클래스/메소드 포함
- 감사(Audit) 로깅:
  - 주요 데이터 변경 이력 추적
  - 사용자 인증 시도 기록
  - 중요 API 접근 기록
- 성능 모니터링:
  - API 응답 시간 기록
  - 데이터베이스 쿼리 실행 시간 모니터링
  - 주기적 리소스 사용량 체크

## 예외 처리
- 전역 예외 처리기 구현:
  - @RestControllerAdvice 및 @ExceptionHandler 사용
  - 일관된 오류 응답 형식 정의 (상태 코드, 메시지, 에러 코드 등)
- 사용자 정의 예외 클래스 생성:
  - 비즈니스 예외와 시스템 예외 분리
  - 적절한 HTTP 상태 코드 매핑
- 예외 처리 시 민감한 정보 노출 방지
- 외부 API 호출 시 예외 처리 철저히 구현

## 캐싱 전략
- 읽기 빈도가 높고 변경이 적은 데이터에 캐싱 적용
- 캐시 TTL(Time-To-Live) 적절히 설정
- 캐시 무효화 전략 구현:
  - 데이터 변경 시 관련 캐시 자동 무효화
  - 배치 작업을 통한 주기적 캐시 갱신
- 캐시 계층화:
  - 첫 번째 레벨: 로컬 메모리 캐시
  - 두 번째 레벨: 분산 캐시(Redis 등)

## 테스트 코드 작성
- 단위 테스트:
  - 모든 비즈니스 로직에 대한 단위 테스트 작성
  - Mockito를 활용한 의존성 모킹
  - 코드 커버리지 70% 이상 유지
- 통합 테스트:
  - 주요 API 엔드포인트에 대한 통합 테스트 구현
  - @SpringBootTest 활용
- 테스트 데이터 관리:
  - 테스트용 데이터셋 정의
  - @TestConfiguration을 활용한 테스트 환경 구성
  - FixtureMonkey 활용한 테스트 데이터 생성

## 코드 품질 유지
- 정적 코드 분석 도구 활용:
  - SonarQube 규칙 준수
  - SpotBugs를 통한 버그 패턴 검출
- 코드 리뷰 체크리스트:
  - 보안 취약점 검토
  - 성능 이슈 검토
  - 코드 중복 확인
  - 테스트 코드 작성 여부 확인
- 명명 규칙 준수:
  - 클래스: PascalCase, 명사형
  - 변수 및 메소드: camelCase
  - 상수: UPPER_SNAKE_CASE

## 문서화 규칙
- API 문서화:
  - OpenAPI/Swagger 사용
  - 모든 API 엔드포인트에 상세한 설명 추가
  - 요청/응답 예제 포함
- 코드 주석:
  - 복잡한 비즈니스 로직에 주석 추가
  - 메소드 설명, 파라미터, 반환값 문서화
  - TODO, FIXME 태그 활용하여 작업 추적

## 성능 최적화
- 데이터베이스 최적화:
  - 적절한 인덱스 설계
  - 실행 계획 분석을 통한 쿼리 최적화
  - 배치 처리 활용
- N+1 문제 방지:
  - @EntityGraph 활용
  - 페치 조인(Fetch Join) 사용
  - QueryDSL을 활용한 최적화된 쿼리 작성
- 비동기 처리:
  - @Async 활용한 병렬 처리
  - 이벤트 기반 아키텍처 적용
  - 대용량 작업은 백그라운드 작업으로 처리

## 배포 및 CI/CD
- 환경별 설정 분리:
  - application-{env}.yml 활용
  - 환경별 프로필 설정
- 데이터베이스 마이그레이션:
  - Flyway 또는 Liquibase 활용
  - 스키마 변경 이력 관리
- CI/CD 파이프라인:
  - 코드 빌드 및 테스트 자동화
  - 정적 코드 분석 통합
  - 단계별 배포 전략 수립(개발 → 테스트 → 스테이징 → 운영)

## API 설계 원칙
- RESTful API 설계:
  - URI는 리소스를 표현하며, 동사 사용 지양
  - 적절한 HTTP 메소드 사용(GET, POST, PUT, DELETE)
  - 응답 상태 코드의 일관된 사용
- 버전 관리:
  - URI 경로에 버전 정보 포함(/api/v1/resources)
  - 하위 호환성 유지
- 페이징, 필터링, 정렬:
  - 일관된 쿼리 파라미터 사용
  - 페이지 기반 및 커서 기반 페이징 구현
- API 요청/응답 표준화:
  - 응답 형식 통일(상태 코드, 메시지, 데이터)
  - 오류 응답 형식 표준화 